<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turing-Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .trackContainer {
            display: flex;
            flex-wrap: wrap;
            transform: translateX(50%);
        }

        .trackContainer,
        .container {
            position: relative;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        .track {
            display: flex;
            flex-wrap: wrap;
            /*margin-right: -15px;
            margin-left: -15px;*/
            width: 100%;
        }

        .cell {
            flex: 0 0 10px;
            max-width: 10px;
            position: relative;
            width: 100%;
            padding-right: 15px;
            padding-left: 15px;
            transition: transform 0.5s ease-in-out;
            border: solid transparent 1px;
        }

        .border {
            border: solid black 1px;
        }

        .pointer>svg {
            transform: rotate(90deg);
            left: 50%;
        }

        .pointerTrack {
            /*flex: 0 0 100%;
            max-width: 100%;*/
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .pointer {
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>

<body>
    <div id="container" class="container">
        <div class="pointerTrack">
            <div class="pointer">
                <svg class="bi bi-backspace-reverse-fill" width="2em" height="2em" viewBox="0 0 16 16"
                    fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd"
                        d="M0 3a2 2 0 0 1 2-2h7.08a2 2 0 0 1 1.519.698l4.843 5.651a1 1 0 0 1 0 1.302L10.6 14.3a2 2 0 0 1-1.52.7H2a2 2 0 0 1-2-2V3zm9.854 2.854a.5.5 0 0 0-.708-.708L7 7.293 4.854 5.146a.5.5 0 1 0-.708.708L6.293 8l-2.147 2.146a.5.5 0 0 0 .708.708L7 8.707l2.146 2.147a.5.5 0 0 0 .708-.708L7.707 8l2.147-2.146z" />
                </svg>
            </div>
        </div>
        <div class="trackContainer">
            <div id="track1" class="track">
                <div class="cell border">1</div>
                <div class="cell border">2</div>
                <div class="cell border">3</div>
                <div class="cell border">4</div>
            </div>
            <div id="track2" class="track">
                <div class="cell"></div>
                <div class="cell border">1</div>
                <div class="cell border">2</div>
                <div class="cell border">2</div>
            </div>
        </div>
    </div>

    <script>
        const tracks = document.querySelector(".trackContainer");
        var allCells = document.querySelectorAll(".cell");
        const allTracks = document.querySelectorAll(".track");
        const cellWidth = allCells[0].offsetWidth;
        var cellsByTrack = [];
        var trackContent = [];
        var currOffset = 0;

        function init() {
            tracks.style.transform = "translateX(50%) translateX(-" + (cellWidth / 2) + "px)";
            reinitTrackContent();
        }

        function reinitTrackContent() {
            trackContent = [];
            cellsByTrack = [];
            for (var i = 0; i < allTracks.length; i++) {
                trackContent.push([]);
                cellsByTrack.push([]);
            }
        }

        function gotoCell(num) {
            currOffset = num;
            for (var i = 0; i < allCells.length; i++) {
                //allCells[i].style.transform = "translateX(-" + (cellWidth * (num + 0.5)) + "px)";
                allCells[i].style.transform = "translateX(-" + (num * 100) + "%)";
            }
        }

        function writeToTrack(trackNum, text) {
            allCells = [];
            reinitTrackContent();
            for (var i = 0; i < allTracks.length; i++) {
                while (allTracks[i].firstElementChild) {
                    allTracks[i].firstElementChild.remove();
                }
            }
            for (var i = 0; i < text.length; i++) {
                for (var a = 0; a < allTracks.length; a++) {
                    if (a == trackNum) {
                        trackContent[a][i] = text.charAt(i);
                        const newTop = document.createElement("div");
                        newTop.className = "cell border";
                        newTop.innerText = text.charAt(i);
                        allTracks[a].appendChild(newTop);
                        cellsByTrack[a][i] = newTop;
                        allCells.push(newTop);
                    } else {
                        trackContent[a][i] = "";
                        const newBottom = document.createElement("div");
                        newBottom.className = "cell";
                        allTracks[a].appendChild(newBottom);
                        cellsByTrack[a][i] = newBottom;
                        allCells.push(newBottom);
                    }
                }
            }
        }

        function insertOntoTrack(trackNum, end, char) {
            for (var a = 0; a < allTracks.length; a++) {
                if (a == trackNum) {
                    const newTop = document.createElement("div");
                    newTop.className = "cell border";
                    newTop.innerText = char;
                    newTop.style.transform = "translateX(-" + (currOffset * 100) + "%)";
                    if (end) {
                        allTracks[a].appendChild(newTop);
                        cellsByTrack[a].splice(cellsByTrack[a].length, 0, newTop);
                        trackContent[trackNum].splice(trackContent[trackNum].length, 0, char);
                    } else {
                        allTracks[a].prepend(newTop);
                        cellsByTrack[a].splice(0, 0, newTop);
                        trackContent[trackNum].splice(0, 0, char);
                    }
                    allCells.push(newTop);
                } else {
                    const newBottom = document.createElement("div");
                    newBottom.className = "cell";
                    newBottom.style.transform = "translateX(-" + (currOffset * 100) + "%)";
                    if (end) {
                        allTracks[a].appendChild(newBottom);
                        cellsByTrack[a].splice(cellsByTrack[a].length, 0, newBottom);
                        trackContent[trackNum].splice(trackContent[trackNum].length, 0, "");
                    } else {
                        allTracks[a].prepend(newBottom);
                        cellsByTrack[a].splice(0, 0, newBottom);
                        trackContent[trackNum].splice(0, 0, "");
                    }
                    allCells.push(newBottom);
                }
            }
        }

        function changeCellContent(track, index, newChar) {
            cellsByTrack[track][index].classList.add("border");
            cellsByTrack[track][index].innerText = newChar;
        }

        function stepTuringNormal(program, steps) {
            const numSteps = steps > 0 ? steps : -1;
            if (numSteps == 0) {
                return program.hasEnded;
            }
            const currChr = trackContent[program.track][program.currentCellIndex]
            if (program.fun[program.currState] && program.fun[program.currState][currChr]) {
                trackContent[program.track][program.currentCellIndex] = program.fun[program.currState][currChr].newChr;
                changeCellContent(program.track, program.currentCellIndex, program.fun[program.currState][currChr].newChr);
                if (program.fun[program.currState][currChr].move == "l") {
                    if (program.currentCellIndex > 0) {
                        program.currentCellIndex--;
                        gotoCell(program.currentCellIndex);
                    } else {
                        insertOntoTrack(program.track, false, "_");
                    }
                } else if (program.fun[program.currState][currChr].move == "r") {
                    if (program.currentCellIndex < trackContent[program.track].length - 1) {
                        program.currentCellIndex++;
                        gotoCell(program.currentCellIndex);
                    } else {
                        insertOntoTrack(program.track, true, "_");
                        program.currentCellIndex++;
                        gotoCell(program.currentCellIndex);
                    }
                }
                if (program.endStates.includes(program.currState)) {
                    program.hasEnded = true;
                    program.wasSuccessFull = true;
                }
                program.currState = program.fun[program.currState][currChr].newState;
            } else {
                program.hasEnded = true;
                program.wasSuccessFull = false;
            }
            if ((numSteps - 1) != 0 && !program.hasEnded) {
                setTimeout(() => {
                    stepTuringNormal(program, numSteps - 1);
                }, 1000);
            }
            return program.hasEnded;
        }

        function stepTuringDual(program, steps) {
            const numSteps = steps > 0 ? steps : -1;
            if (numSteps == 0) {
                return program.hasEnded;
            }
            const currChrs = [];
            for (var i = 0; i < allTracks.length; i++) {
                if (trackContent[i][program.currentCellIndex] && trackContent[i][program.currentCellIndex].length > 0) {
                    currChrs.push(trackContent[i][program.currentCellIndex]);
                }
            }
            const currChrsStr = currChrs.join(";");
            if (program.fun[program.currState] && program.fun[program.currState][currChrsStr]) {
                const newChrs = program.fun[program.currState][currChrsStr].newChr.split(";");
                for (var i = 0; i < newChrs.length; i++) {
                    trackContent[i][program.currentCellIndex] = newChrs[i];
                    changeCellContent(i, program.currentCellIndex, newChrs[i]);
                }
                if (program.fun[program.currState][currChrsStr].move == "l") {
                    if (program.currentCellIndex > 0) {
                        program.currentCellIndex--;
                        gotoCell(program.currentCellIndex);
                    } else {
                        insertOntoTrack(program.track, false, "_");
                    }
                } else if (program.fun[program.currState][currChrsStr].move == "r") {
                    if (program.currentCellIndex < trackContent[program.track].length - 1) {
                        program.currentCellIndex++;
                        gotoCell(program.currentCellIndex);
                    } else {
                        insertOntoTrack(program.track, true, "_");
                        program.currentCellIndex++;
                        gotoCell(program.currentCellIndex);
                    }
                }
                if (program.endStates.includes(program.currState)) {
                    program.hasEnded = true;
                    program.wasSuccessFull = true;
                }
                program.currState = program.fun[program.currState][currChrsStr].newState;
            } else {
                program.hasEnded = true;
                program.wasSuccessFull = false;
            }
            if ((numSteps - 1) != 0 && !program.hasEnded) {
                setTimeout(() => {
                    stepTuringDual(program, numSteps - 1);
                }, 1000);
            }
            return program.hasEnded;
        }

        function convertMachineToIneffective(program) {
            var newProgram = {
                fun: {},
                currentCellIndex: 0,
                track: trackNum,
                endStates: ["f"],
                currState: "s",
                hasEnded: false,
                wasSuccessFull: false,
                alphabet: [],
                exec: (steps) => { stepTuringDual(this, steps) }
            };
            program.alphabet.forEach(char => {
                newProgram.fun["s"][char] = {
                    newState: "d",
                    newChr: "w;q1",
                    move: "n"
                };
                newProgram.fun["l_from"][char + ";q0"] = {
                    newState: "d",
                    newChr: "w;q_0",
                    move: "l"
                };
                newProgram.fun["r_from"][char + ";q0"] = {
                    newState: "d",
                    newChr: "w;q_0",
                    move: "l"
                };
            });
            return newProgram;
        }

        function execNormalProgram(trackNum, programText) {
            var operations = programText.split("\n").map(l => l.trim().toLowerCase()).filter(l => !l.startsWith("#") && l.length != 0);
            var program = {
                fun: {},
                currentCellIndex: 0,
                track: trackNum,
                endStates: ["f"],
                currState: "s",
                hasEnded: false,
                wasSuccessFull: false,
                alphabet: [],
                states: ["s", "f"],
                exec: (steps) => { stepTuringNormal(this, steps) }
            };
            operations.forEach(line => {
                var parts = line.split(",");
                if (!program.fun[parts[0]]) {
                    program.fun[parts[0]] = {};
                }
                program.fun[parts[0]][parts[1]] = {
                    newState: parts[2],
                    newChr: parts[3],
                    move: parts[4]
                };
                if (program.alphabet.indexOf(parts[3]) < 0) {
                    program.alphabet.push(parts[3]);
                }
                if (program.states.indexOf(parts[2]) < 0) {
                    program.states.push(parts[2]);
                }
            });

            return program;
        }

        init();

    </script>
</body>

</html>